# 네모네모 개발 계획

## 1. 프로젝트 개요
- 서비스 위치: `https://domain.com/nemonemo`
- 개발 배경: 기존 라이어게임(`https://domain.com/liargame`) 운영 노하우를 바탕으로, 네모네모 로직(일명 노노그램) 퍼즐을 웹에서 즐길 수 있는 신규 게임을 구축한다.
- 핵심 가치: 직관적인 퍼즐 플레이 경험, 플랫폼 간 일관된 사용자 계정/친구/랭킹 경험, 지속 가능한 퍼즐 공급 파이프라인.

## 2. 목표 및 성공 지표
- **핵심 목표**
  - 출시 1개월 내 DAU 1,000명
  - 월간 퍼즐 클리어 수 10,000건
  - 평균 세션 이탈률 30% 이하 유지
- **부가 목표**
  - 기존 라이어게임 계정/지갑/포인트 연동
  - 주간 신규 퍼즐 20개 이상 자동/수동 등록

## 3. 범위 및 주요 기능
- **퍼즐 플레이**: 좌표 힌트를 기반으로 격자에 도트를 채우는 기본 게임 루프, 오답 체크, 힌트 사용, 자동 저장.
- **퍼즐 관리**: 내부 에디터, 퍼즐 검수 워크플로, 난이도 분류, 메타데이터 관리.
- **진행/랭킹 시스템**: 클리어 시간/정확도 기반 점수, 시즌별 랭킹, 업적 배지.
- **사회적 기능**: 친구 초대, 퍼즐 공유, 관전 모드(Phase 2 예정).
- **운영 도구**: 대시보드, 로그/분석 수집, 공지사항/이벤트 배포.

## 4. 기술 스택 방향성
- **백엔드**: Spring Boot (Kotlin), JPA + QueryDSL 기반 퍼즐/사용자 데이터 관리, Redis(세션/랭킹 캐시), WebSocket(SockJS + STOMP) 혹은 RSocket을 통한 실시간 상태 동기화, Testcontainers 기반 통합테스트, Flyway 마이그레이션.
- **프론트엔드**: React + Vite + TypeScript, Zustand 상태관리 유지, Canvas 또는 SVG 기반 그리드 렌더링, React Query로 API 통신, WebSocket 클라이언트 재사용, Tailwind CSS 도입 검토(대규모 UI 구성 시) 혹은 기존 디자인 시스템 활용.
- **인프라**: Docker 기반 퍼즐 빌드/테스트, CI( GitHub Actions )로 백엔드/프론트엔드 테스트 및 빌드, 스테이징/프로덕션 환경 분리, S3 + CloudFront 정적 자산 배포.

## 5. 단계별 개발 로드맵

### Phase 0. 리서치 & 기획 (1주)
- 네모네모 로직 게임 규칙 정밀 분석 및 경쟁 서비스 벤치마킹.
- 사용자 스토리/사용 시나리오 정의, UX 플로우 초안 작성.
- 기존 라이어게임 계정 시스템/인프라 재검토, 연동 범위 결정.
- 산출물: 요구사항 정의서, IA/와이어프레임 초안, 기술 검토 메모.

### Phase 1. 시스템 설계 & 기반 구축 (2주)
- 데이터 모델 설계: 퍼즐, 힌트, 사용자 진행상태, 랭킹 테이블 정의.
- API 명세(Swagger/Redoc) 수립, 이벤트 스키마 정의.
- 프로젝트 스캐폴딩: `backend-nemonemo` 모듈 생성 또는 기존 모듈 확장, `frontend/nemonemo` 라우팅/페이지 초기화.
- 공통 라이브러리 추출: 퍼즐 검증 로직, 공용 DTO, 인증/권한 모듈.
- CI 파이프라인 확장: 분기 빌드, 코드 스타일 체크, 테스팅 기본 구성.
- 산출물: ERD, OpenAPI 스펙, 초기 프로젝트 구조, CI 설정 PR.

### Phase 2. 퍼즐 엔진 & 에디터 개발 (3주)
- 서버: 퍼즐 생성/검증 알고리즘, 난이도 계산, 퍼즐 CRUD API.
- 프론트: 퍼즐 에디터 UI, 실시간 검증, 퍼즐 미리보기 캔버스 구현.
- 퍼즐 버전 관리 및 승인 워크플로.
- 자동 테스트: 알고리즘 단위테스트, API 통합테스트.
- 산출물: 퍼즐 생성기/검증기, 관리자용 에디터 페이지, 퍼즐 승인 플로우.

### Phase 3. 플레이 경험 구현 (4주)
- 프론트: 메인 퍼즐 플레이어, 힌트 버튼, 입력 모드 전환, 반응형 레이아웃, 접근성 대응.
- 백엔드: 세션 저장, 진행상태 자동 저장 API, 힌트 사용/오답 기록 로직.
- 실시간 연동: WebSocket으로 동시 진행 상황/진행률 전송, 관전자 읽기 API 설계.
- QA: 퍼즐 난이도별 플레이테스트, 크로스브라우저 체크, 모바일 대응.
- 산출물: 플레이 UI, 게임 세션 API, 실시간 알림 프로토타입.

### Phase 4. 랭킹/진행/커뮤니티 확장 (2주)
- 랭킹/업적: 점수 산출 규칙, 시즌 리셋 로직, 리더보드 API/UI.
- 친구/공유: 친구 시스템 연계, 퍼즐 공유 링크, 단축 URL.
- 알림: 이메일/푸시(선택) 알림 인프라 연동.
- 산출물: 랭킹 페이지, 시즌 관리 도구, 친구 초대 플로우.

### Phase 5. 베타 테스트 & 런칭 준비 (2주)
- 클로즈드 베타: 핵심 유저 대상 테스트, 피드백 수집.
- 관제: 로그 수집(ELK/Opensearch), A/B 실험 준비, 알림/이벤트 시스템 검증.
- 운영/CS: FAQ, 튜토리얼, 장애 대응 매뉴얼 작성.
- 런칭 체크리스트: 성능 부하 테스트, 보안 점검, 배포 자동화.
- 산출물: 베타 피드백 리포트, 런칭 승인서, 운영 문서.

### Phase 6. 정식 오픈 & 운영 (지속)
- KPI 모니터링, 퍼즐 공급 파이프라인 유지.
- 시즌별 콘텐츠 업데이트, 이벤트 기획/전개.
- 사용자 피드백 기반 기능 백로그 관리.
- 기술 부채 정리, 성능 최적화 주기적 실행.

## 6. 리스크 및 대응 전략
- **퍼즐 생성 난이도**: 자동 생성 알고리즘 정확도 확보가 어려울 수 있으므로 1차 버전은 수동 제작 + 검수 툴에 집중하고, 생성 알고리즘은 베타 후속 과제로 분리.
- **실시간 동기화 부하**: 대규모 동시 접속 시 스케일 문제가 발생 가능. Redis 기반 Pub/Sub 와 수평 확장 전략 미리 마련.
- **콘텐츠 고갈**: 크리에이터 커뮤니티 프로그램 기획, UGC 퍼즐 제출 플로우 도입 검토.
- **UX 복잡도**: 신규 유저 온보딩 튜토리얼/가이드 영상 제작으로 이탈 방지.

## 7. 일정/역할 제안
- PO/디자이너: 요구사항, UX 설계, 콘텐츠 전략 1명
- 백엔드 개발: 2명 (게임 로직/인프라 분담)
- 프론트엔드 개발: 2명 (플레이어 UI, 에디터/UI 라이브러리)
- QA & 라이브 운영: 1명 (베타 테스트, 운영 가이드)

## 8. 후속 과제 및 확장 아이디어
- 모바일 전용 앱(React Native) 혹은 PWA 최적화.
- 사용자 생성 퍼즐 마켓플레이스, 커스텀 룰 세트.
- 멀티플레이 협력/대전 모드.
- AI 기반 퍼즐 추천 및 난이도 자동 조정.
