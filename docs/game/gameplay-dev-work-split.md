# 실제 게임 진행 페이지 개발 - 영역별 작업 분리

## Backend 개발 순서

- [x] **1. 사전 설계 및 계약 합의**
  - [x] 프롬프트에 정의된 목표/문제/필수 요구사항을 기반으로 게임 단계, 플레이어 상태, 이벤트 타입을 백엔드 관점에서 구조화한다.
  - [x] 프런트엔드와 공유할 DTO · 이벤트 페이로드 명세를 `src/main/kotlin/.../dto` 와 `frontend/src/api` 기준으로 정리하고 버전 태깅을 합의한다.
  - [x] Redis vs In-memory 하이브리드 운용 방식을 결정하고, `application-example.yml`/`env-base.js` 템플릿에 필요한 설정 키를 추가한다.

- [x] **2. 세션 및 플레이어 라이프사이클 구축**
  - [x] 세션 기반 인증 흐름을 재사용하여 입장 시 사용자 ID/닉네임/아바타를 확보하고 방장·일반 권한을 구분한다.
  - [x] 플레이어 상태 모델(대기, 준비, 게임 중, 탈락, 라이어, 관전자)을 엔티티/스토어에 반영하고 중복 접속·중간 퇴장·브라우저 종료 이벤트 처리 로직을 구현한다.
  - [x] 방장 위임, 강제 종료, 추방 등의 제어 명령을 정의하고 권한 검증을 추가한다.

- [x] **3. 실시간 통신 계층 확장**
  - [x] 기존 STOMP 엔드포인트를 확장해 방 단위 토픽과 입장/퇴장/상태변경/타이머/채팅 이벤트를 브로드캐스트한다.
  - [x] 서버 시간을 단일 소스로 삼아 카운트다운 정보를 전파하고, 이벤트 소싱 또는 상태 스냅샷으로 신규 참여자 초기 동기화를 지원한다.
  - [x] 구독 요청에 대한 역할·권한 체크를 강화해 라이어 비밀 정보가 잘못 노출되지 않도록 한다.

- [x] **4. 게임 라운드 상태 머신 구현**
  - [x] 주제 배정 → 주제 공유 → 라이어 지정 → 발언 → 토론 → 투표 → 결과 발표 → 점수 정산 순서를 상태 머신으로 모델링한다.
  - [x] 단계 진입·종료 조건(타이머 만료, 발언 완료)을 정의하고 잘못된 순서의 요청을 차단한다.
  - [x] 라이어와 시민에게 서로 다른 페이로드를 송신하고, 라운드 간 점수 누적과 다음 라운드 초기화를 처리한다.

- [x] **5. 상호작용 엔드포인트 및 검증 로직 구현**
  - [x] 발언 제출, 의심 토론, 투표, 결과 확인 API와 WebSocket 이벤트를 설계하고 서버 측 유효성 검사를 추가한다.
  - [x] 채팅 메시지 저장·필터링·신고 플로우를 정의하고 타임라인 기록 포맷을 확정한다.
  - [x] 시스템/방장 메시지를 구분해 공지 채널로 강조 표시할 수 있도록 메타데이터를 부여한다.

- [x] **6. 복구 및 운영성 강화**
  - [x] 재접속 시 필요한 상태(현재 단계, 남은 시간, 역할, 채팅 로그)를 빠르게 재구성하는 복구 엔드포인트를 제공한다.
  - [x] 이벤트 처리 및 상태 전이에 대한 로깅·모니터링 지표를 추가하고 장애 대응 시나리오를 문서화한다.
  - [x] 오류/예외(네트워크 지연, 잘못된 단계 진입) 상황에서 일관된 에러 코드를 정의한다.

- [ ] **7. 테스트 및 부하 검증**
  - [ ] MockK 기반 단위/슬라이스 테스트로 단계 전이, 라이어·주제 분배, 투표 집계를 검증한다.
  - [ ] WebSocketTestClient 통합 테스트로 최소 3인(라이어 1, 시민 2) 시나리오를 자동화한다.
  - [ ] 20명 동시 접속 부하를 가정한 메시지 처리량과 타이머 정확도를 프로파일링하고 결과를 공유한다.

## Frontend 개발 순서

- [x] **1. 요구사항 정리 및 공용 계약 반영**
  - [x] 프롬프트의 목표 경험/필수 기능/UX 개선 항목을 화면 흐름으로 변환하고 라운드 단계를 라우트·상태 차트로 시각화한다.
  - [x] 백엔드와 합의한 DTO · 이벤트 스키마를 `frontend/src/api`와 타입 정의에 반영하며 버전 식별자를 관리한다.
  - [x] 게임 상태 관리 전략(Zustand/Redux/React Query 조합)을 결정하고 초기 스토어 구조를 설계한다.

- [ ] **2. 실시간 상태 동기화 인프라 구축**
  - [x] STOMP WebSocket 클라이언트 훅을 구현해 방 단위 토픽에 구독하고, 서버 푸시를 우선하는 동기화 흐름을 마련한다.
  - [x] 입장 시 상태 스냅샷 수신, 이벤트 병합, 역순 정렬 등 클라이언트 캐시 정책을 정의한다.
  - [ ] 역할·권한별 이벤트 필터링을 적용해 라이어 비밀 정보가 일반 사용자 UI에 렌더링되지 않도록 한다.

- [ ] **3. 기본 레이아웃 및 공통 컴포넌트 구성**
  - [ ] 플레이어 목록, 단계 표시 상단 바, 타이머 영역, 채팅/발언 패널로 페이지 스켈레톤을 구성한다.
  - [ ] 데스크톱/모바일 브레이크포인트를 정의하고 1열/2열 전환 레이아웃을 설계한다.
  - [ ] 글로벌 상태와 UI 컴포넌트 간 인터페이스를 확정하고 Storybook 초기 스토리를 추가한다.

- [ ] **4. 라운드 단계별 상호작용 UI 구현**
  - [ ] 주제 공개, 라이어 지정, 발언 제출, 토론, 투표, 결과 확인 등 각 단계에 대응하는 뷰·폼·액션을 제작한다.
  - [ ] 단계 전환 시 애니메이션과 진행 바 업데이트를 연결하고, 서버 단계와 불일치 시 교정 로직을 추가한다.
  - [ ] 점수 요약과 라운드 기록 카드를 구현해 다음 라운드로 자연스럽게 넘어가도록 한다.

- [ ] **5. 채팅 및 메시징 기능 완성**
  - [ ] 실시간 텍스트 채팅 리스트, 입력창, 메시지 전송 피드백을 구현한다.
  - [ ] 사용자명/역할/타임스탬프 표시 규칙과 부적절한 메시지 신고 UI를 제공한다.
  - [ ] 방장·시스템 공지 메시지를 시각적으로 구분하고 고정 영역에 표출한다.

- [ ] **6. UX · 접근성 · 반응형 보강**
  - [ ] 타이머 대비 색상, 마지막 10초 알림, 역할별 강조, 라이어 비밀 오버레이 마스킹을 적용한다.
  - [ ] 색 대비, 키보드 포커스 경로, aria 태그 등 접근성 요소를 점검하고 적용한다.
  - [ ] 규칙/도움말 패널, 오류 토스트, 재연결 인디케이터를 추가해 신규 사용자 경험을 개선한다.

- [ ] **7. 회복력 및 상태 복구 처리**
  - [ ] 새로고침·재접속 시 서버 스냅샷을 받아 스토어를 재구성하는 로직을 구현한다.
  - [ ] 네트워크 지연·연결 해제·잘못된 단계 요청에 대한 예외 처리와 사용자 피드백을 정비한다.
  - [ ] 로깅/모니터링 이벤트를 정의해 운영 중 문제 추적이 가능하도록 한다.

- [ ] **8. 프런트엔드 테스트 및 검증**
  - [ ] Vitest + Testing Library로 상태 동기화, 조건부 렌더링, 타이머 표시 테스트를 작성한다.
  - [ ] Storybook 스냅샷과 시각적 회귀 테스트를 갱신하고 접근성 검사(Axe 등)를 실행한다.
  - [ ] Playwright 다중 세션 시나리오(라이어 1, 시민 2)와 핵심 UX 플로우를 자동화한다.

