# 실제 게임 진행 페이지 개발 프롬프트

## 배경 및 목적
- 웹/모바일 클라이언트에서 라이어 게임이 끊김 없이 진행될 수 있도록 실시간 상호작용, 게임 로직, UI/UX를 전면 재구성한다.
- 현재 페이지는 정적 정보만을 노출하고 있어, 입장/진행/결과에 대한 실시간 공유가 불가능하며 게임 경험을 만들 수 없다.
- 본 프롬프트는 프런트엔드와 백엔드 양 측의 구현 범위, 기술적 제약, 검증 방법을 명확히 정의해 완전한 게임 플레이 경험을 제공하는 것이 목표다.

## 현재 파악된 주요 문제점
1. 실시간 동기화 부재: 첫 입장자가 이후 참여자를 볼 수 없고, 현재 상태가 모두에게 즉시 반영되지 않는다.
2. 채팅 기능 누락: 라이어 게임 특성상 동시에 진행되는 실시간 대화가 핵심인데, 현 UI에는 아예 존재하지 않는다.
3. 게임 코어 로직 미구현: 주제·키워드·라이어 지정, 의심/토론/투표 단계, 결과 공개 절차 등 핵심 흐름이 모두 빠져 있다.
4. 플레이어 생명주기 관리 부재: 대기 → 게임 중 → 탈퇴/추방 등의 상태 전이가 정의되지 않아 빈방/유령 플레이어가 방치된다.
5. 데이터 일관성 문제: 새로고침/재접속 시 기존 참여 정보가 보존되지 않아 세션이 끊긴다.
6. 권한 및 역할 표시 부족: 방장, 라이어, 시민 등 역할에 따른 권한 구분과 시각적 강조가 없다.
7. 오류/예외 처리 미비: 네트워크 지연, 장비 해제, 잘못된 단계 진입 시 사용자에게 피드백이 없다.
8. 반응형 UI 미지원: 모바일 사용자가 대부분임에도 레이아웃이 고정되어 있어 가독성이 떨어진다.
9. 접근성 고려 미흡: 색 대비, 키보드 내비게이션, 스크린리더 태그 등 기본 접근성 요소가 빠져 있다.
10. 보조 정보 부재: 규칙 설명, 남은 시간, 진행 단계 등 맥락 정보가 없어 신규 사용자가 적응하기 어렵다.
11. 확장성 부족: 향후 라운드 수 조정, 다양한 테마/난이도 추가를 고려한 설계가 되어 있지 않다.

## 목표 경험 정의
- 누구나 방에 입장하자마자 현재 플레이어 목록과 진행 중인 단계·타이머를 즉시 확인할 수 있어야 한다.
- 음성 없이 텍스트 채팅만으로도 토론, 라이어 추리, 투표 등 전체 라운드를 원활히 수행할 수 있어야 한다.
- 각 라운드가 끝나면 모든 사용자에게 자동으로 결과가 방송되고, 다음 라운드로 자연스럽게 전환되어야 한다.
- 연결 끊김 또는 재접속 상황에서도 사용자는 해당 라운드의 현 상태로 복귀해야 한다.

## 필수 기능 요구사항
### 1. 사용자 세션 및 참여 관리
- 세션 기반 인증 인프라를 재사용하여 입장 시 사용자 ID, 닉네임, 아바타를 확보한다.
- 방장 권한(게임 시작/강제 종료/플레이어 추방)과 일반 참여자 권한을 분리한다.
- 플레이어 상태 모델(대기, 준비 완료, 게임 중, 탈락, 라이어, 관전자 등)을 명확히 정의하고 DB/인메모리 스토어에 반영한다.
- 중복 접속, 중간 퇴장, 브라우저 종료 등 이벤트에 따른 정리 로직을 구현한다.

### 2. 실시간 동기화 및 통신
- 기존 WebSocket(STOMP) 인프라 계층을 재사용/확장한다.
- 방 단위 채널을 생성하고, 입장/퇴장/상태 변경/타이머/채팅 등 모든 이벤트를 브로드캐스트한다.
- 서버 기준 시간을 단일 소스로 사용하고, 클라이언트에는 카운트다운만 UI로 렌더하도록 한다.
- 백엔드에서 이벤트 소싱 또는 상태 스냅샷을 관리해 새로 합류한 사용자에게 현재 상태를 즉시 전송한다.

### 3. 게임 라운드 플로우
- 구성 요소: (1) 주제/키워드 배정, (2) 주제 공유, (3) 라이어 지정, (4) 라운드별 발언, (5) 의심 토론, (6) 투표, (7) 라이어 실토/결과 발표, (8) 점수 정산.
- 백엔드는 상태 머신을 구축해 각 단계를 순차적으로 진행하며, 유효성 검사를 통해 순서가 어긋난 요청을 차단한다.
- 라이어에게만 숨겨진 답안, 일반 플레이어에게는 정답 키워드를 송신하고, 노출 범위를 엄격히 분리한다.
- 타이머 만료/모든 발언 완료 등의 트리거에 따라 자동으로 다음 단계로 전환한다.
- 멀티 라운드 지원과 라운드 간 점수 누적을 고려한다.

### 4. 채팅 및 상호작용
- 실시간 텍스트 채팅, 라운드별 발언 제출 UI, 투표 UI를 구현한다.
- 채팅 메시지는 사용자명, 역할, 타임스탬프를 포함하고, 부적절한 메시지 필터링 또는 신고 후 처리를 고려한다.
- 발언/투표 데이터는 서버 검증을 거쳐 타임라인에 기록되도록 하고, UI에 단계별로 분리해 노출한다.

### 5. 보조 기능 및 유지보수성
- 방장/시스템 메시지를 구분하여 공지 형태로 강조한다.
- 방장도 게임 내부에서는 일반 사용자와 동일하게 취급하지만, 게임 시작 전 대기 공간에서 권한을 가진다.
- 재접속 시 필요한 최소 상태(현재 단계, 남은 시간, 역할, 채팅 로그 일부)를 빠르게 복구한다.
- 프런트엔드 상태 관리(Store) 구조를 재편해 서버 상태와 클라이언트 캐시가 일관되게 유지되도록 한다.
- 이벤트/상태 변경과 관련된 로깅, 모니터링 포인트를 추가해 운영 안정성을 확보한다.

## UI/UX 개선 요구사항 (10)
- 플레이어 목록 패널에 상태(준비, 발언 중, 탈락, 라이어 의심 등)를 색상·아이콘으로 구분한다.
- 단계 전환 시 상단 진행 바와 애니메이션을 제공해 현재 라운드의 위치를 직관적으로 알린다.
- 고정된 채팅 영역과 발언 제출 패널을 분리해 동시에 확인·입력할 수 있게 한다.
- 데스크톱/모바일 브레이크포인트를 정의해 레이아웃이 자동으로 스택 또는 2단 구조로 전환되도록 한다.
- 실시간 타이머는 큰 글씨와 대비 색상을 사용하고, 마지막 10초에는 시각/사운드 알림을 제공한다.
- 라이어만 볼 수 있는 비밀 정보 영역을 오버레이 카드로 제공하고, 실수로 노출되지 않도록 마스킹한다.
- 라운드 규칙/진행 도움말을 우측 패널 또는 모달로 제공해 신규 사용자도 빠르게 학습하도록 한다.
- 투표 단계에서는 사용자 카드가 클릭 가능한 버튼으로 변하며, 선택 상태를 시각적으로 강조한다.
- 게임 종료 후에는 결과 요약(득표수/정답/라운드별 MVP)을 카드 형태로 정리해 공유 가능하도록 한다.
- 에러/네트워크 끊김, 재시도 상황에 대해 상단 토스트와 재연결 인디케이터를 제공해 불안감을 줄인다.

## 기술 및 설계 고려사항
- 백엔드는 Kotlin + Spring 기반으로, WebSocket/STOMP 엔드포인트와 이벤트 퍼블리셔를 구성한다.
- 상태 저장은 Redis 또는 in-memory + DB 하이브리드를 고려하며, 단일 장애 지점을 피하기 위한 분산 키 전략을 마련한다.
- 프런트엔드는 React Query 또는 Zustand/Redux를 이용해 서버 상태를 관리하고, optimistic update 대신 서버 푸시를 우선한다.
- DTO/도메인 모델은 공용 `frontend/src/api` 스키마와 `src/main/kotlin/.../dto`를 동기화해 타입 불일치를 방지한다.
- 보안: 역할 노출, 라이어 비밀 정보 전달 시 HTTPS·권한 체크를 재검토하고 서버 측에서도 잘못된 구독을 차단한다.

## 개발 산출물 체크리스트
- 백엔드: 방/라운드/플레이어 엔티티, 상태 머신 서비스, WebSocket 컨트롤러, 통합 테스트(MockK+WebSocketTestClient) 작성.
- 프런트엔드: 실시간 상태 스토어, WebSocket 클라이언트 훅, 게임 단계 컴포넌트, 채팅/투표 UI, E2E 테스트(Playwright) 추가.
- 공용: 이벤트/DTO 명세서, API 문서, UI/UX 프로토타입(Figma), 환경 변수 정리(`application-example.yml`, `env-base.js`).

## 테스트 및 검증
- 백엔드: 단계 전이, 라이어/주제 분배, 투표 결과 계산을 커버하는 단위·슬라이스 테스트 작성.
- 프런트엔드: Vitest + Testing Library로 상태 동기화, 타이머 표시, UI 조건부 렌더링을 검증하고 Storybook 스냅샷을 갱신한다.
- 통합: 최소 3명(라이어 1, 시민 2)의 멀티탭 시나리오를 Playwright 다중 세션으로 검증한다.
- 부하: 15명 동시 접속 기준으로 WebSocket 메시지 처리량과 타이머 정확도를 프로파일링한다.

## 완료 조건
- 모든 필수 기능 및 UI/UX 개선 요구사항이 구현되어 실제 게임 진행이 가능하며, 재접속/오류 상황에서도 회복이 가능해야 한다.
- `./gradlew test`, `npm run test:run`, `npm run lint`, `npm run test:e2e`가 성공적으로 통과해야 한다.
- 사용자 스토리(Done) 정의와 QA 시나리오 문서가 업데이트되어야 하며, 신규/수정된 스크린샷을 첨부한다.
- 운영 환경 배포 전에 테스트용 `.env.local` 및 `application-example.yml` 템플릿이 갱신되어 있어야 한다.
