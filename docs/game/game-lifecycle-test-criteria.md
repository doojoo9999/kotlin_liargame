# 게임 라이프사이클 엔드투엔드 테스트 합격 기준

본 문서는 세 명의 실제 플레이어(브라우저 세션)를 이용해 홈페이지 진입부터 게임 종료 및 퇴장까지의 전 과정을 검증하기 위한 합격 기준을 정의한다. 모든 항목을 충족하지 못하면 테스트는 실패로 간주한다.

## 1. 테스트 환경 준비
- **백엔드**: `./gradlew bootRun`으로 20021 포트에서 실행 (프로필 `dev`).
- **프론트엔드**: `npm run dev -- --host 0.0.0.0 --port 5173`으로 실행.
- **브라우저 세션**: 동일 PC에서 서로 다른 3개의 브라우저 탭/세션을 사용하거나 MCP Browser 인스턴스 3개를 활용한다. 모든 브라우저는 로컬 프론트엔드 `http://218.150.3.77:5173` 에 접근한다.
- **테스트 계정**: 닉네임 기반 로그인만 사용하므로 사전 회원가입 불필요. 중복 닉네임은 허용되지 않으므로 고유 닉네임을 사용한다.
- **데이터 사전 조건**: 승인된 주제가 최소 1개 이상 있으며, 해당 주제에 승인된 단어가 5개 이상 존재해야 한다. 없을 경우 관리자 기능 또는 REST API로 생성/승인해야 한다.

## 2. 테스트 시나리오 및 합격 기준

### 2.1 초기 접근 및 인증
1. **홈 페이지 접속**: 세 브라우저 모두 `/` 로 접근 시 로그인 화면이 로드되고, 인증 상태가 없음을 표시해야 한다. (Auth Store가 `isAuthenticated=false`)
2. **닉네임 로그인**: 각 브라우저에서 고유 닉네임을 입력 후 로그인 버튼 클릭 시 `POST /api/v1/auth/login` 이 성공(HTTP 200, `success=true`) 해야 하며, 로그인 즉시 `/lobby` 로 리다이렉트된다.
3. **세션 유지 확인**: 로그인 완료 후 새로고침 시 자동으로 `/lobby` 가 유지되고, `refresh-session` 호출이 `success=true` 로 반환되어야 한다.

### 2.2 로비 및 방 생성
1. **로비 렌더링**: `/lobby` 진입 시 게임 목록, 생성 버튼, 현재 접속 인원이 표시되어야 한다. 최소 한 개의 "방 만들기" UI 가 노출되어야 한다.
2. **방 생성** (호스트 브라우저):
   - 방 이름, 라운드 수, 참가 인원(3명), 라이어 수(1명), 주제 선택(랜덤 또는 수동 선택)을 지정하고 "방 생성" 시 `POST /api/v1/game/create` 가 201/200 으로 응답하며 게임 번호를 반환해야 한다.
   - 생성 직후 호스트의 게임 상태 조회(`/api/v1/game/{gameNumber}`)가 `gameState=WAITING`, `players` 목록에 호스트 1명만 포함되어야 한다.
   - 다른 두 브라우저의 로비 목록에 새로 생성된 방이 실시간으로 나타나야 한다 (WebSocket 업데이트 또는 pull 로 5초 이내 반영).

### 2.3 게임 참가
1. **플레이어 2, 3 입장**:
   - 각 브라우저에서 방 선택 후 "참가" 클릭 시 `POST /api/v1/game/join` 이 200 으로 응답하고 JSON 에 현재 플레이어 목록이 3명으로 갱신되어야 한다.
   - 호스트 브라우저에서도 실시간으로 참가자 목록이 최신화되어야 하며, 각 플레이어 카드의 준비 상태가 `READY` 로 전환되어야 한다.
2. **중복 입장 방지**: 동일 브라우저에서 재참가 시도가 거절(400 또는 409) 되어야 한다.

### 2.4 게임 시작 및 스피치 단계
1. **게임 시작 권한**: 방장만 "게임 시작" 버튼이 활성화되어야 하며, 다른 플레이어는 비활성화 상태여야 한다.
2. **게임 시작**: 방장이 시작 클릭 시 `POST /api/v1/game/start` 가 200 응답하고 `gameState=IN_PROGRESS`, `currentPhase=SPEECH`, `turnOrder` 배열이 반환되어야 한다.
3. **역할/단어 배포**: 각 브라우저의 게임 화면에서 배정된 역할이 올바르게 표시되어야 한다.
   - 시민은 주제와 단어를 볼 수 있어야 하고,
   - 라이어는 주제를 모른다는 컴포넌트가 노출되어야 하며 단어가 빈값/마스킹 처리되어야 한다.
4. **턴 안내**: 현재 턴 플레이어 카드에 하이라이트와 타이머가 표시되고, 채팅창에 시스템 메시지가 브로드캐스트되어야 한다.
5. **힌트 제출**: 턴 플레이어가 힌트 제출 시 `POST /api/v1/game/hint` 가 200 응답하고, 해당 플레이어 상태가 `GAVE_HINT` 로 바뀌며 채팅에 힌트가 노출되어야 한다. 차례는 `turnOrder` 순으로 진행되어야 한다. 모든 플레이어가 힌트를 제출하면 다음 단계로 진행해야 한다.

### 2.5 라이어 지목 투표 단계
1. **단계 전환**: 모든 힌트 제출 후 `currentPhase` 값이 `VOTING_FOR_LIAR` 로 전환되고, 투표 UI (플레이어 리스트 + 선택 가능 버튼)가 활성화되어야 한다.
2. **투표 제한**: 각 플레이어는 한 번만 투표할 수 있어야 하며, 본인에게 투표할 수 없고, 다시 투표하려 하면 거절(400)되어야 한다.
3. **투표 결과 공유**: 투표 완료 후 `accusedPlayer` 필드가 채워지고, 채팅/알림으로 지목 결과가 전달되어야 한다.

### 2.6 변론 단계
1. **단계 전환**: 지목 결과가 확정되면 `currentPhase=DEFENDING` 이 되어야 한다.
2. **변론 제출**: 지목된 플레이어만 변론 입력 UI 가 활성화되고, 변론 제출 시 `POST /api/v1/game/submit-defense` 가 200 응답해야 한다.
3. **변론 종료**: 지목된 플레이어가 변론 종료 버튼을 누르거나 타임아웃 발생 시 `POST /api/v1/game/defense/end` 결과로 `currentPhase=VOTING_FOR_SURVIVAL` 로 전환되어야 한다.

### 2.7 최종 투표 단계
1. **UI**: 모든 플레이어에게 "처형 투표" UI 가 노출되어야 한다 (찬성/반대 스위치 등).
2. **투표 수행**: 각 플레이어가 `POST /api/v1/game/vote/final` 호출 시 200 응답하고 중복 투표가 거부되어야 한다.
3. **투표 결과**: 과반수 찬성 시 지목된 플레이어 `isAlive=false`, 아니면 생존 유지. 결과가 실시간으로 동기화되어야 한다.

### 2.8 라이어 주제 맞히기 단계
1. **단계 전환**: 최종 투표 완료 후 `currentPhase=GUESSING_WORD` 가 되어야 한다.
2. **UI 표시**: 라이어만 단어 입력 UI 가 활성화되어야 하며 시민은 "라이어가 추측 중" 안내만 보여야 한다.
3. **추측 제출**: `POST /api/v1/game/guess-word` 호출 시 200 응답하고, 정답 여부(`isCorrect`)가 결과 모달/토스트로 노출되어야 한다.

### 2.9 게임 종료 및 결과 화면
1. **최종 상태**: 게임 상태가 `gameState=ENDED` 로 바뀌어야 하고, `winner`, `scores`, `roundHistory` 등이 채워져야 한다.
2. **결과 페이지**: 모든 플레이어가 `/results/{gameId}` 로 이동하여 결과 요약, 라운드 로그, 채팅 기록을 확인할 수 있어야 한다.
3. **로비 복귀**: "로비로 돌아가기" 동작 시 `POST /api/v1/game/leave` 가 호출되어 세션이 방에서 제거되어야 하며, 로비 목록에서 해당 게임이 제거되거나 `ENDED` 상태로 표시되어야 한다.

### 2.10 세션 종료
1. **로그아웃**: 필요 시 `POST /api/v1/auth/logout` 호출로 로그아웃이 정상 동작해야 한다.
2. **중복 로그인 방지**: 로그아웃 전 다른 창에서 동일 닉네임으로 로그인하려고 하면 충돌 메시지가 발생해야 한다.

## 3. 검증 체크리스트
- [ ] 모든 HTTP 요청이 성공(2xx) 상태를 반환했고 예외가 발생하지 않았다.
- [ ] 각 단계가 지정된 `currentPhase` 값으로 정확히 전환되었다.
- [ ] 세 플레이어의 UI 가 서로 다른 역할/권한에 맞게 다르게 표시되었다.
- [ ] WebSocket 또는 폴링 기반 실시간 동기화가 지연 없이 동작했다 (5초 내 업데이트).
- [ ] 게임 종료 후 모든 세션이 `/lobby` 로 정상 복귀했다.
- [ ] 브라우저를 닫거나 새로고침해도 세션 유지/복원이 기대대로 이루어졌다.

위 항목을 모두 만족하면 게임 라이프사이클 테스트는 합격으로 판정한다.

## 4. 2025-10-04 수동 테스트 실행 결과
- 실행 도구: `scripts/manual-game-lifecycle.js` (Playwright 3세션 자동화)
- 백엔드 빌드: Redis 연동 선택형 + 방 번호 중복 방지 수정 적용본
- 프론트엔드 접속지: `http://218.150.3.77:5173`
- 테스트 계정: `TESTONE`, `TESTTWO`, `TESTTHREE`
- 게임 진행 요약:
  - 로그인 및 로비 진입, 게임 생성(#1) 후 3인 입장/준비 완료 확인
  - 스피치 → 라이어 지목 → 변론 → 최종 투표 → 라이어 추측 → 결과 화면까지 모든 단계 자동 진행
  - 최종 투표로 라이어(`TESTTHREE`) 탈락, 추측 실패 처리 확인
  - 각 세션에서 `/results/1` 및 로비 복귀(`POST /game/leave`) 정상 동작, 새로고침 시 세션 유지 확인
- 캡처: `playwright-report/manual-*.png` 7종 (waiting, joined, phase별 UI, 결과, 로비)
- 체크리스트: 파일 상단 3.항 전체 충족 ✅

### 4.1 2025-10-05 재검증 (UTF-8 스트림)
- 두 차례 실행으로 라이어 추측 실패/성공 모두 검증 (`LIAR_GUESS_MODE=incorrect` ↔ `LIAR_GUESS_MODE=correct`).
- 실패 케이스: `guessResult.isCorrect=false`, `winner=CITIZENS` 로그 확인, 게임 종료 후 시민 승리 유지.
- 성공 케이스: `guessResult.isCorrect=true`, `winner=LIARS` 반환으로 라이어 정답 처리 확인(최종 스코어는 기존 규칙에 따라 0점이지만 API 응답이 승리 팀을 명시).
- 로그 예시: `playwright-report/manual-guess-phase.png`, `Guess evaluation {"liarGuessMode":"correct","isCorrect":true,"winner":"LIARS"}`.
- 모든 실행에서 플레이어 세션 UTF-8 로케일 유지, 한글 힌트/토스트/로그에 깨짐 없음.
