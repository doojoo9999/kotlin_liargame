개발 시 단일 진실 공급원: `root/new-front.md` 을 반드시 참고하십시오.

천재적 사고 공식화 프롬프트 (Genius Thinking Formula Prompt)

1. 현재 작성되어있는 CSS와 Component, Hook 을 최대한 활용해야 합니다. 각 파일이 가지는 책임과 역할을 분명히 설정하고, 너무 큰 역할을 하지 않도록 주의하세요.

2. 당신은 사용자의 어떤 질문이나 아이디어, 정보를 받으면, 아래 사고법 중에 가장 적합한 방식을 두개를 선택하여 혼합하여 분석하세요(1000자 이상)

3. 분석을 토대로 천재적 아이디어를 2개 이상 1000자 이상 출력합니다

아래 공식들은 참고하세요.

---

## 1. 천재적 통찰 도출 공식 (Genius Insight Formula)

GI = (O × C × P × S) / (A + B)

- GI(Genius Insight) = 천재적 통찰
- O(Observation) = 관찰의 깊이 (1-10점)
- C(Connection) = 연결의 독창성 (1-10점)
- P(Pattern) = 패턴 인식 능력 (1-10점)
- S(Synthesis) = 종합적 사고 (1-10점)
- A(Assumption) = 고정관념 수준 (1-10점)
- B(Bias) = 편향 정도 (1-10점)

적용법: 주제에 대해 각 요소의 점수를 매기고, 고정관념과 편향을 최소화하면서 관찰-연결-패턴-종합의 순서로 사고를 전개하세요.

---

## 2. 다차원적 분석 프레임워크

MDA = Σ[Di × Wi × Ii] (i=1 to n)

- MDA(Multi-Dimensional Analysis) = 다차원 분석 결과
- Di(Dimension i) = i번째 차원에서의 통찰
- Wi(Weight i) = i번째 차원의 가중치
- Ii(Impact i) = i번째 차원의 영향력

분석 차원 설정:
- D1 = 시간적 차원 (과거-현재-미래)
- D2 = 공간적 차원 (로컬-글로벌-우주적)
- D3 = 추상적 차원 (구체-중간-추상)
- D4 = 인과적 차원 (원인-과정-결과)
- D5 = 계층적 차원 (미시-중간-거시)

---

## 3. 창의적 연결 매트릭스

CC = |A ∩ B| + |A ⊕ B| + f(A→B)

- CC(Creative Connection) = 창의적 연결 지수
- A ∩ B = 두 개념의 공통 요소
- A ⊕ B = 배타적 차이 요소
- f(A→B) = A에서 B로의 전이 함수

연결 탐색 프로세스:
1. 직접적 연결 찾기
2. 간접적 연결 탐색
3. 역설적 연결 발견
4. 메타포적 연결 구성
5. 시스템적 연결 분석

---

## 4. 문제 재정의 알고리즘

PR = P₀ × T(θ) × S(φ) × M(ψ)

- PR(Problem Redefinition) = 재정의된 문제
- P₀ = 원래 문제
- T(θ) = θ각도만큼 관점 회전
- S(φ) = φ비율로 범위 조정
- M(ψ) = ψ차원으로 메타 레벨 이동

재정의 기법:
- 반대 관점에서 보기 (θ = 180°)
- 확대/축소하여 보기 (φ = 0.1x ~ 10x)
- 상위/하위 개념으로 이동 (ψ = ±1,±2,±3)
- 다른 도메인으로 전환
- 시간 축 변경

---

## 5. 혁신적 솔루션 생성 공식

IS = Σ[Ci × Ni × Fi × Vi] / Ri

- IS(Innovative Solution) = 혁신적 솔루션
- Ci(Combination i) = i번째 조합 방식
- Ni(Novelty i) = 참신성 지수
- Fi(Feasibility i) = 실현 가능성
- Vi(Value i) = 가치 창출 정도
- Ri(Risk i) = 위험 요소

솔루션 생성 방법:
- 기존 요소들의 새로운 조합
- 전혀 다른 분야의 솔루션 차용
- 제약 조건을 오히려 활용
- 역방향 사고로 접근
- 시스템 전체 재설계

---

## 6. 인사이트 증폭 공식

IA = I₀ × (1 + r)ⁿ × C × Q

- IA(Insight Amplification) = 증폭된 인사이트
- I₀ = 초기 인사이트
- r = 반복 개선율
- n = 반복 횟수
- C = 협력 효과 (1-3배수)
- Q = 질문의 질 (1-5배수)

증폭 전략:
- 'Why'를 5번 이상 반복
- 'What if' 시나리오 구성
- 'How might we' 질문 생성
- 다양한 관점자와 토론
- 아날로그 사례 탐구

---

## 7. 사고의 진화 방정식

TE = T₀ + ∫[L(t) + E(t) + R(t)]dt

- TE(Thinking Evolution) = 진화된 사고
- T₀ = 초기 사고 상태
- L(t) = 시간 t에서의 학습 함수
- E(t) = 경험 축적 함수
- R(t) = 반성적 사고 함수

진화 촉진 요인:
- 지속적 학습과 정보 습득
- 다양한 경험과 실험
- 깊은 반성과 메타인지
- 타인과의 지적 교류
- 실패로부터의 학습

---

## 8. 복잡성 해결 매트릭스

CS = det|M| × Σ[Si/Ci] × ∏[Ii]

- CS(Complexity Solution) = 복잡성 해결책
- det|M| = 시스템 매트릭스의 행렬식
- Si = i번째 하위 시스템 해결책
- Ci = i번째 하위 시스템 복잡도
- Ii = 상호작용 계수

복잡성 분해 전략:
- 시스템을 하위 구성요소로 분해
- 각 구성요소 간 관계 매핑
- 핵심 레버리지 포인트 식별
- 순차적/병렬적 해결 순서 결정
- 전체 시스템 최적화

---

## 9. 직관적 도약 공식

IL = (S × E × T) / (L × R)

- IL(Intuitive Leap) = 직관적 도약
- S(Silence) = 정적 사고 시간
- E(Experience) = 관련 경험 축적
- T(Trust) = 직관에 대한 신뢰
- L(Logic) = 논리적 제약
- R(Rationalization) = 과도한 합리화

직관 활성화 방법:
- 의식적 사고 중단
- 몸과 마음의 이완
- 무의식적 연결 허용
- 첫 번째 떠오르는 아이디어 포착
- 판단 없이 수용

---

## 10. 통합적 지혜 공식

IW = (K + U + W + C + A) × H × E

- IW(Integrated Wisdom) = 통합적 지혜
- K(Knowledge) = 지식의 폭과 깊이
- U(Understanding) = 이해의 수준
- W(Wisdom) = 지혜의 깊이
- C(Compassion) = 공감과 연민
- A(Action) = 실행 능력
- H(Humility) = 겸손함
- E(Ethics) = 윤리적 기준

---

## 사용 가이드라인

1. 단계적 적용: 각 공식을 순차적으로 적용하여 사고를 심화시키세요.

2. 반복적 개선: 한 번의 적용으로 끝내지 말고 여러 번 반복하여 정교화하세요.

3. 다양한 관점: 서로 다른 배경을 가진 사람들과 함께 공식을 적용해보세요.

4. 실험적 태도: 공식을 기계적으로 따르기보다는 창의적으로 변형하여 사용하세요.

5. 균형적 접근: 분석적 사고와 직관적 사고를 균형 있게 활용하세요.

---

프로젝트에 대한 이해
# Junie Project Guidelines + Project Context Briefing (Single Source of Truth)

이 문서는 AI 코드 어시스턴트와 개발자가 본 프로젝트를 100% 이해하고 일관된 규칙으로 작업할 수 있도록 하는 단일 진실 공급원(Single Source of Truth)입니다.
- 파트 A: 프로젝트 컨텍스트 브리핑(아키텍처/흐름/폴더 책임/라이브러리/운영 규칙)
- 파트 B: 작업 규칙(Junie 개발/리팩토링 가이드라인)

문서가 최신 상태를 유지해야 하며, 구조/아키텍처 변경 시 본 문서만 갱신합니다.

---

## 파트 A. 프로젝트 컨텍스트 브리핑

### 1) 프로젝트 개요
- 목적: 실시간 라이어 게임 웹 애플리케이션
- 주요 도메인:
    - 방 로비(생성/참가/목록/검색)
    - 실시간 게임(턴/발언/투표/판정/정산)
    - 채팅
    - 주제/단어 콘텐츠 관리(관리/추가)
    - 관리자 모니터링(통계/플레이어/방 상태)

### 2) 기술 스택 요약
- 프런트엔드
    - React 18.2, Vite 5, React Router 7
    - 상태: Zustand 5(도메인 파사드), React Query v5(서버 상태)
    - UI: Mantine 7, styled-components 6, framer-motion 12
    - 폼/검증: react-hook-form 7, zod 4
    - 네트워킹: axios 1, SockJS + STOMP 7(WebSocket)
    - 유틸: dayjs, lodash-es, clsx, react-window(가상 스크롤), lottie-react 등
- 백엔드
    - Kotlin 1.9, Java 17, Spring Boot 3.x (Jakarta EE), Spring Data JPA, Spring MVC
    - WebSocket(STOMP), Spring Session
    - DB: (개발) H2 또는 MySQL, JPA/Hibernate
    - 문서화: SpringDoc OpenAPI(스웨거)

### 3) 상위 아키텍처
- 클라이언트(브라우저)
    - HTTP/REST: axios(apiClient)로 백엔드 API 호출
    - WS/STOMP: SockJS+STOMP로 실시간 구독/브로드캐스트
    - 캐싱/동기화: React Query v5로 서버 상태 캐시 + WebSocket push 시 setQueryData로 부분 갱신
- 서버(Spring Boot)
    - Controller(REST) + MessageMapping(STOMP)
    - Service(도메인 로직) + Repository(JPA)
    - 실시간 프로토콜에서 발생하는 변경을 캐시 무효화/부분 업데이트 이벤트로 브로드캐스트

### 4) 프런트엔드 폴더 역할과 책임
- src/
    - pages/
        - 페이지 컨테이너(얇은 조립자): 데이터 훅 조합, 라우팅 경계, 다이얼로그 상태, 이벤트 바인딩
        - 외부 공개 API: index.jsx (배럴)
        - 라우터 로더(Data Router)와 결합 가능(사전 데이터 로딩)
    - components/
        - 프리젠테이션/복합 컴포넌트 집합
        - 내부 세분화 자유, 외부는 배럴(index.js)만 import
        - 예: 로비 헤더, 방 리스트 테이블, 카드, 다이얼로그 등
    - hooks/
        - 재사용 가능한 도메인/서비스 훅
        - React Query 쿼리/뮤테이션, WebSocket 효과, 폼 조립 훅 등
    - stores/
        - Zustand 스토어(로컬 UI/도메인 파사드 상태)
        - 전역 UI 또는 비서버 상태(예: 다이얼로그 열림, 임시 폼 값) 관리
    - utils/
        - 공용 유틸(로그, 상태 텍스트/색상 매핑, 에러 맵핑, 날짜 포맷 등)
    - styles/
        - 테마/스타일 헬퍼, 전역 스타일
    - api/
        - apiClient(axios 인스턴스/인터셉터)
        - 각 도메인 API 함수(gameApi 등)
        - queryKeys(쿼리 키 네임스페이스 중앙화)
    - socket/
        - STOMP 클라이언트 래퍼 및 구독/복원/재연결 로직
    - loaders/
        - React Router 로더(사전 데이터 병렬 로딩, 부분 실패 허용)
    - features/<domain>/
        - 특정 도메인(예: game-monitoring, room, chat)의 내부 구성 요소/훅/서비스/배럴

핵심 원칙
- 외부는 alias + barrel(index)만 import (import/no-internal-modules 위반 금지)
- 컨테이너는 얇게, 프리젠테이션은 세분화
- 서버 상태는 React Query, 로컬/파사드는 Zustand
- WebSocket 업데이트는 setQueryData로 부분 갱신 우선

### 5) 프런트엔드 데이터/흐름

- 초기 진입
    - 라우팅: React Router 7(Data Router) 사용
    - 로더에서 병렬로 rooms/subjects 등 사전 데이터 수집(Promise.allSettled)
    - 페이지 컨테이너는 로더 데이터 + React Query 쿼리의 initialData/동기화 패턴을 사용

- 방 목록/참여/생성
    - 목록: useQuery(queryKeys.rooms.list(...))로 페칭, WebSocket 이벤트로 setQueryData 부분 갱신
    - 생성/참여: useMutation → 성공 시 rooms 관련 쿼리 invalidate 또는 부분 갱신, 라우팅 이동
    - 비밀번호 방: 다이얼로그에서 안전하게 제출

- 게임 진행(요약)
    - 입장 시 현재 게임 상태/플레이어 목록/라운드/타이머 질의
    - STOMP 구독: 게임 상태 토픽 수신 → 캐시/뷰 업데이트
    - 발언/투표/판정 이벤트는 API 또는 STOMP 송신 → 서버 브로드캐스트 → 클라이언트 캐시 동기화

- 관리자 모니터링
    - 통계/방/플레이어 리스트를 쿼리 + STOMP 갱신
    - 끊김/재연결/구독 복원 자동화
    - 대용량 대비: react-window로 가상 리스트 구조 준비

- 로깅/에러 처리
    - utils/logger로 환경별 로그 레벨 제어(import.meta.env.DEV에서 상세)
    - API 에러 → 표준 코드 맵핑(UX 메시지 정규화), 401은 인터셉터에서 로그아웃 브로드캐스트
    - WebSocket 오류/재연결 상태 표준 컴포넌트로 표시

### 6) 사용 라이브러리와 적용 규칙(요지)
- React Query v5
    - staleTime/gcTime 표준화, refetchOnWindowFocus: false, setQueryData로 부분 갱신, 필요 시 invalidate
    - queryKeys 중앙화, 네임스페이스 규칙 준수
- Zustand
    - 파사드 훅으로만 외부 노출, 내부 구현은 숨김
    - UI 상태/임시 폼/선택 값 등 서버 상태가 아닌 것만
- SockJS + STOMP
    - 연결 가드(중복 연결 방지), 멱등 구독, 재연결 시 자동 구독 복원
    - 수신 메시지는 즉시 캐시에 반영(setQueryData)하여 UI 반응성 확보
- react-hook-form + zod
    - 스키마 외부 정의, mode: onBlur, 에러 메시지 일관 표시
- Mantine + styled-components + framer-motion
    - Mantine 컴포넌트 우선, 시각 효과는 motion 조합
    - 큰 비주얼은 lazy/Suspense로 지연 로드
- 유틸(dayjs/lodash-es/clsx)
    - lodash-es는 개별 임포트
    - dayjs는 필요한 플러그인만 확장, locale 등록 1회
    - 클래스 결합은 clsx 표준

### 7) 환경/구성
- 패키지 관리자: npm
- Vite 환경 변수:
    - import.meta.env.DEV/PROD 사용, 사용자 변수는 VITE_* 접두어
- API baseURL/WS endpoint는 환경에 따라 주입(VITE_API_BASE_URL 등)
- 보안:
    - 토큰/세션은 인터셉터로 주입/401 공통 처리
    - 입력값은 zod로 검증, 로그에는 민감정보 마스킹

### 8) 백엔드 서비스 흐름(도메인 관점)

- 인증/세션
    - 닉네임 단순 인증 또는 토큰 기반, 세션/쿠키로 클라이언트 식별
    - 401 처리 시 클라이언트 자동 로그아웃 이벤트 발생

- 방(Room) 수명주기
    1) 생성: 방장/설정(최대 인원, 라운드, 주제/단어 세트, 모드, 비밀번호)
    2) 대기: 플레이어 입장/퇴장, 인원/중복 검사, 비밀번호 검증
    3) 시작: 상태를 IN_PROGRESS로 전환, 턴/발언 순서/타이머 초기화
    4) 진행: 각 라운드에 대해 발언 → 투표 → 판정 → (필요 시) 라이어 주제 맞추기
    5) 종료: 결과 정리, 통계 업데이트, 상태를 ENDED/TERMINATED로 전환
    6) 청소: 일정 시간 이후 리소스 정리 또는 명시적 종료

- 게임 로직(라운드 단위)
    - 역할 할당(라이어/시민), 단어 노출(라이어는 비공개)
    - 발언 타이머/순서 제어
    - 투표 집계/동률/패널티 처리
    - 라이어 맞추기 기회/정답 판정
    - 승패/점수/히스토리 기록

- 채팅/실시간 이벤트
    - STOMP 토픽 설계: 방 단위, 관리자 모니터링, 유저 큐 등
    - 서버는 상태 변경 시 관련 토픽에 브로드캐스트
    - 클라이언트는 해당 토픽 구독 후 캐시/뷰 업데이트

- 주제/단어 콘텐츠
    - 주제/단어 CRUD(관리 권한), 방 생성 시 선택
    - 추후 서버 페이지네이션/검색/태그 필터 확장 가능

- 관리자 모니터링
    - 통계(활성 방, 접속 플레이어, 평균 대기/게임 시간 등)
    - 실시간 방/플레이어 업데이트 이벤트 발행
    - 강제 종료/강제 퇴장 등의 어드민 액션(확장 여지)

- 영속성/JPA
    - Aggregate 기준 트랜잭션 경계 설정(방/게임/라운드/플레이어)
    - 낙관적 락/버전/상태 머신으로 동시성 충돌 최소화
    - 읽기 전용 쿼리는 읽기 스냅샷/캐시 고려

### 9) 품질/운영 가드
- 빌드: npm run build 무오류
- 린트: npm run lint 무경고 권장
- 테스트: 핵심 훅/서비스 단위 테스트(추가 예정), WebSocket 모킹
- 접근성/성능:
    - role/aria 보존, 키보드 내비게이션
    - 큰 리스트는 react-window 준비
    - React.memo/커스텀 비교로 리스트 행 렌더 최적화
- 모니터링/로깅:
    - logger 유틸로 통일, 오류는 사용자 메시지 + 개발자 로그 분리
    - STOMP 상태(연결/재연결/오류) 가시화

---

## 파트 B. Junie 개발/리팩토링 가이드라인(운영 규칙)

아래 규칙은 기존 문서를 계승/정비한 것으로, 모든 PR은 이를 만족해야 합니다.

### 1) 기술 스택 및 기본 규칙
- FE: React 18, Vite 5, styled-components, Mantine 7, framer-motion 12, lucide-react, @tanstack/react-query v5, react-window, Zustand
- 패키지 관리자: npm
- ENV: Vite 표준(import.meta.env.*, VITE_* 접두어)
- 로깅: utils/logger 사용(개발 모드에서만 상세)

### 2) 프로젝트 구조(요지)
- src/
    - pages/ (페이지 컨테이너, index.jsx 배럴만 공개)
    - components/ (공용/복합 컴포넌트, index.js 배럴)
    - hooks/ (재사용 훅)
    - utils/ (상태/문자열/포맷/상수)
    - styles/ (테마/스타일 헬퍼)
    - stores/ (Zustand 등 상태)
    - api/ (apiClient, queryKeys, 도메인별 API)
    - socket/ (STOMP 래퍼)
    - loaders/ (React Router Data API 로더)
- 원칙: 외부는 배럴만 import

### 3) Barrel Export(공용 진입점)
- 각 최상위/기능 폴더는 반드시 index.(js|jsx) 제공
- 내부 파일 직접 import 금지
- 세분화/재배치 시 외부 경로 불변

### 4) Import 경로 & Alias
- Vite alias(@, @components, @pages, @hooks, @utils, @api, @socket) 사용
- jsconfig/tsconfig paths 일치

### 5) 네이밍 & 파일 규칙
- JSX 포함 파일: .jsx (JSX를 .js에서 사용 금지)
- 접미사: *.utils.js, *.hook.js, *.icons.js, *.styles.js
- Feature 단위 내부 구조 권장(components/hooks/utils/styles/README)

### 6) 리팩토링 원칙(체인지 버짓)
- 한 번에 1 스코프(1 파일/폴더)
- 변경 파일 ≤ 10, 라인 최소화
- 외부 공개 API/경로/동작/문구 불변(변경은 별도 태스크)

### 7) 품질 가드(필수)
- npm run build, npm run lint, (테스트 도입 시) npm test
- 접근성/성능 체크:
    - aria/role 유지
    - react-window itemKey/overscan
    - styled-components 정적화
    - React Query 옵션(staleTime/gcTime/refetchOnWindowFocus)

### 8) ESLint(권장)
- import/no-internal-modules: 에러(배럴만 허용)
- react/jsx-filename-extension: ['error', { extensions: ['.jsx'] }]
- 환경 분기: process.env.* 금지 → import.meta.env.*

### 9) 커밋/PR DoD
- [ ] 배럴 공개 API 경로 불변
- [ ] 내부 분리/이동은 배럴로 캡슐화
- [ ] 빌드/린트 통과 로그 첨부
- [ ] 변경 요약(분리/추출/메모화 등)
- [ ] 회귀 위험/추가 제안

### 10) 로깅/ENV
- logger.debugLog/infoLog/warnLog/errorLog…
- 상세 로그는 import.meta.env.DEV일 때만

### 11) 성능/안정성 체크리스트
- 옵저버/타이머 cleanup 보장
- WebSocket 수명주기: connect→subscribe→handle→unsubscribe→disconnect
- React Query: setQueryData 우선, 필요 시 invalidate
- 대형 리스트: memo, 안정 key, 스타일 상수화

### 12) 작업용 프롬프트 템플릿
역할: React 18/Vite 프로젝트의 구조/성능/안정성 개선. 외부 API/경로/동작 변경 금지.  
대상: <상대 경로 또는 폴더>  
목표: <관심사 분리/성능/접근성/표준화 등 구체 목표>  
지침:
- 배럴(index) 공개 API만 유지/수정
- import/no-internal-modules 위반 금지
- JSX는 .jsx에서만, Vite ENV 표준 준수
- 빌드/린트 무오류/무경고  
  산출물:
- 변경/신규 파일 목록 + 변경 요약
- 빌드/린트 통과 로그
- 스모크 결과(기능/성능/접근성)  
  DoD:
- 외부 경로 불변, 배럴 경유, 품질 가드 통과

### 13) FAQ
- 파일 수 증가? → 외부는 배럴 하나, 내부는 자유
- JSX 파싱 에러? → JSX는 .jsx에서만
- ENV/로그? → Vite 표준 + logger

### 14) Composition-first(중요)
- 금지: GameContext, apiClient, gameApi 등 코어에 대규모 비즈니스 로직/JSX 직접 추가
- 원칙:
    1) 컨테이너(얇게) + 프리젠테이션(세분화)
    2) 기존 컴포넌트/훅/서비스 조합 우선
    3) 새 로직은 features/<도메인>/*에 추가 + 배럴로 노출
- 확장 포인트:
    - 데이터: React Query 훅/서비스 모듈 → 컨테이너에서 조립
    - 상태: Zustand/Context는 파사드 훅으로만 접근
    - 실시간: STOMP 래퍼 + useSocketEffects로 연결/구독/해제

### 15) 파일 크기/복잡도 상한(자동 가드)
- 컨테이너: ≤ 200 lines, useEffect ≤ 3, CC ≤ 10
- 프리젠테이션: ≤ 150 lines, 함수당 50 lines 권장
- 훅/서비스: ≤ 200 lines, SRP 유지(혼합 시 내부 훅 분해)

### 16) Import/Barrel 정책(강제)
- 외부 import는 alias + 배럴(index)만
- 내부 경로 직접 import 금지
- JSX는 .jsx, .js는 순수 로직만

### 17) 코어 파일 수정 제한
- GameContext, apiClient, gameApi, socket client 등 계약 변경 금지
- 필요한 경우:
    - 어댑터/파사드 추가(예: useGameFacade, useRoomsService)
    - 배럴 재노출만 허용
    - 불가피 시 별도 태스크/리뷰

### 18) 작업 프롬프트(조합-우선)
역할: 기존 세분화 컴포넌트/훅/서비스 조합으로 기능 구현. 코어 수정 금지.  
대상: <기능/경로>  
목표: <요약. 외부 API/경로/문구 변경 금지>  
지침:
- 기존 자산 검색 → 조합 구현
- 필요 시 features/<domain>/*에 새 자산 추가 + 배럴 노출
- 컨테이너=데이터 조립, 프리젠테이션=UI
- import/no-internal-modules 위반 금지  
  DoD:
- 외부 경로 불변/배럴 경유/빌드·린트 무경고
- 파일 크기 상한/관심사 단일
- 변경/신규 파일 + 요약 + 스모크 결과

---

## 부록. 운영 체크리스트(요약)
- 성능 KPI: 초기 로드 < 2s, 60FPS 리스트 렌더, WebSocket 처리 < 100ms
- UX KPI: 접근성 위반 0, 모바일 우선, 에러율 < 0.1%
- 변화 시나리오:
    - 대용량: 서버 페이지네이션 + react-window
    - 모니터링: 성능/오류 지표 수집
    - 보안: 입력 검증, 로그 마스킹, 레이트 리미트